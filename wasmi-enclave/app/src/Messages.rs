// This file is generated by rust-protobuf 2.0.3. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct InitialMessage {
    // message fields
    field_type: ::std::option::Option<u32>,
    size: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl InitialMessage {
    pub fn new() -> InitialMessage {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    // optional uint32 size = 2;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
}

impl ::protobuf::Message for InitialMessage {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitialMessage {
        InitialMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &InitialMessage| { &m.field_type },
                    |m: &mut InitialMessage| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &InitialMessage| { &m.size },
                    |m: &mut InitialMessage| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InitialMessage>(
                    "InitialMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InitialMessage {
        static mut instance: ::protobuf::lazy::Lazy<InitialMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InitialMessage,
        };
        unsafe {
            instance.get(InitialMessage::new)
        }
    }
}

impl ::protobuf::Clear for InitialMessage {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitialMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitialMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageMsg0 {
    // message fields
    field_type: ::std::option::Option<u32>,
    epid: ::std::option::Option<u32>,
    status: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MessageMsg0 {
    pub fn new() -> MessageMsg0 {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    // required uint32 epid = 2;

    pub fn clear_epid(&mut self) {
        self.epid = ::std::option::Option::None;
    }

    pub fn has_epid(&self) -> bool {
        self.epid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epid(&mut self, v: u32) {
        self.epid = ::std::option::Option::Some(v);
    }

    pub fn get_epid(&self) -> u32 {
        self.epid.unwrap_or(0)
    }

    // optional uint32 status = 3;

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }
}

impl ::protobuf::Message for MessageMsg0 {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.epid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.epid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.epid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.epid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageMsg0 {
        MessageMsg0::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &MessageMsg0| { &m.field_type },
                    |m: &mut MessageMsg0| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "epid",
                    |m: &MessageMsg0| { &m.epid },
                    |m: &mut MessageMsg0| { &mut m.epid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status",
                    |m: &MessageMsg0| { &m.status },
                    |m: &mut MessageMsg0| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageMsg0>(
                    "MessageMsg0",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageMsg0 {
        static mut instance: ::protobuf::lazy::Lazy<MessageMsg0> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageMsg0,
        };
        unsafe {
            instance.get(MessageMsg0::new)
        }
    }
}

impl ::protobuf::Clear for MessageMsg0 {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_epid();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageMsg0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageMsg0 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageMSG1 {
    // message fields
    field_type: ::std::option::Option<u32>,
    GaX: ::std::vec::Vec<u32>,
    GaY: ::std::vec::Vec<u32>,
    GID: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MessageMSG1 {
    pub fn new() -> MessageMSG1 {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    // repeated uint32 GaX = 2;

    pub fn clear_GaX(&mut self) {
        self.GaX.clear();
    }

    // Param is passed by value, moved
    pub fn set_GaX(&mut self, v: ::std::vec::Vec<u32>) {
        self.GaX = v;
    }

    // Mutable pointer to the field.
    pub fn mut_GaX(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.GaX
    }

    // Take field
    pub fn take_GaX(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.GaX, ::std::vec::Vec::new())
    }

    pub fn get_GaX(&self) -> &[u32] {
        &self.GaX
    }

    // repeated uint32 GaY = 3;

    pub fn clear_GaY(&mut self) {
        self.GaY.clear();
    }

    // Param is passed by value, moved
    pub fn set_GaY(&mut self, v: ::std::vec::Vec<u32>) {
        self.GaY = v;
    }

    // Mutable pointer to the field.
    pub fn mut_GaY(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.GaY
    }

    // Take field
    pub fn take_GaY(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.GaY, ::std::vec::Vec::new())
    }

    pub fn get_GaY(&self) -> &[u32] {
        &self.GaY
    }

    // repeated uint32 GID = 4;

    pub fn clear_GID(&mut self) {
        self.GID.clear();
    }

    // Param is passed by value, moved
    pub fn set_GID(&mut self, v: ::std::vec::Vec<u32>) {
        self.GID = v;
    }

    // Mutable pointer to the field.
    pub fn mut_GID(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.GID
    }

    // Take field
    pub fn take_GID(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.GID, ::std::vec::Vec::new())
    }

    pub fn get_GID(&self) -> &[u32] {
        &self.GID
    }
}

impl ::protobuf::Message for MessageMSG1 {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.GaX)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.GaY)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.GID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.GaX.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.GaX);
        }
        if !self.GaY.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.GaY);
        }
        if !self.GID.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.GID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if !self.GaX.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.GaX))?;
            for v in &self.GaX {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.GaY.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.GaY))?;
            for v in &self.GaY {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.GID.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.GID))?;
            for v in &self.GID {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageMSG1 {
        MessageMSG1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &MessageMSG1| { &m.field_type },
                    |m: &mut MessageMSG1| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "GaX",
                    |m: &MessageMSG1| { &m.GaX },
                    |m: &mut MessageMSG1| { &mut m.GaX },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "GaY",
                    |m: &MessageMSG1| { &m.GaY },
                    |m: &mut MessageMSG1| { &mut m.GaY },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "GID",
                    |m: &MessageMSG1| { &m.GID },
                    |m: &mut MessageMSG1| { &mut m.GID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageMSG1>(
                    "MessageMSG1",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageMSG1 {
        static mut instance: ::protobuf::lazy::Lazy<MessageMSG1> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageMSG1,
        };
        unsafe {
            instance.get(MessageMSG1::new)
        }
    }
}

impl ::protobuf::Clear for MessageMSG1 {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_GaX();
        self.clear_GaY();
        self.clear_GID();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageMSG1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageMSG1 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageMSG2 {
    // message fields
    field_type: ::std::option::Option<u32>,
    size: ::std::option::Option<u32>,
    public_key_gx: ::std::vec::Vec<u32>,
    public_key_gy: ::std::vec::Vec<u32>,
    quote_type: ::std::option::Option<u32>,
    spid: ::std::vec::Vec<u32>,
    cmac_kdf_id: ::std::option::Option<u32>,
    signature_x: ::std::vec::Vec<u32>,
    signature_y: ::std::vec::Vec<u32>,
    smac: ::std::vec::Vec<u32>,
    size_sigrl: ::std::option::Option<u32>,
    sigrl: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MessageMSG2 {
    pub fn new() -> MessageMSG2 {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    // optional uint32 size = 2;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    // repeated uint32 public_key_gx = 3;

    pub fn clear_public_key_gx(&mut self) {
        self.public_key_gx.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key_gx(&mut self, v: ::std::vec::Vec<u32>) {
        self.public_key_gx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_public_key_gx(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.public_key_gx
    }

    // Take field
    pub fn take_public_key_gx(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.public_key_gx, ::std::vec::Vec::new())
    }

    pub fn get_public_key_gx(&self) -> &[u32] {
        &self.public_key_gx
    }

    // repeated uint32 public_key_gy = 4;

    pub fn clear_public_key_gy(&mut self) {
        self.public_key_gy.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key_gy(&mut self, v: ::std::vec::Vec<u32>) {
        self.public_key_gy = v;
    }

    // Mutable pointer to the field.
    pub fn mut_public_key_gy(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.public_key_gy
    }

    // Take field
    pub fn take_public_key_gy(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.public_key_gy, ::std::vec::Vec::new())
    }

    pub fn get_public_key_gy(&self) -> &[u32] {
        &self.public_key_gy
    }

    // optional uint32 quote_type = 5;

    pub fn clear_quote_type(&mut self) {
        self.quote_type = ::std::option::Option::None;
    }

    pub fn has_quote_type(&self) -> bool {
        self.quote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_type(&mut self, v: u32) {
        self.quote_type = ::std::option::Option::Some(v);
    }

    pub fn get_quote_type(&self) -> u32 {
        self.quote_type.unwrap_or(0)
    }

    // repeated uint32 spid = 6;

    pub fn clear_spid(&mut self) {
        self.spid.clear();
    }

    // Param is passed by value, moved
    pub fn set_spid(&mut self, v: ::std::vec::Vec<u32>) {
        self.spid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.spid
    }

    // Take field
    pub fn take_spid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.spid, ::std::vec::Vec::new())
    }

    pub fn get_spid(&self) -> &[u32] {
        &self.spid
    }

    // optional uint32 cmac_kdf_id = 7;

    pub fn clear_cmac_kdf_id(&mut self) {
        self.cmac_kdf_id = ::std::option::Option::None;
    }

    pub fn has_cmac_kdf_id(&self) -> bool {
        self.cmac_kdf_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmac_kdf_id(&mut self, v: u32) {
        self.cmac_kdf_id = ::std::option::Option::Some(v);
    }

    pub fn get_cmac_kdf_id(&self) -> u32 {
        self.cmac_kdf_id.unwrap_or(0)
    }

    // repeated uint32 signature_x = 8;

    pub fn clear_signature_x(&mut self) {
        self.signature_x.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_x(&mut self, v: ::std::vec::Vec<u32>) {
        self.signature_x = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signature_x(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.signature_x
    }

    // Take field
    pub fn take_signature_x(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.signature_x, ::std::vec::Vec::new())
    }

    pub fn get_signature_x(&self) -> &[u32] {
        &self.signature_x
    }

    // repeated uint32 signature_y = 9;

    pub fn clear_signature_y(&mut self) {
        self.signature_y.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature_y(&mut self, v: ::std::vec::Vec<u32>) {
        self.signature_y = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signature_y(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.signature_y
    }

    // Take field
    pub fn take_signature_y(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.signature_y, ::std::vec::Vec::new())
    }

    pub fn get_signature_y(&self) -> &[u32] {
        &self.signature_y
    }

    // repeated uint32 smac = 10;

    pub fn clear_smac(&mut self) {
        self.smac.clear();
    }

    // Param is passed by value, moved
    pub fn set_smac(&mut self, v: ::std::vec::Vec<u32>) {
        self.smac = v;
    }

    // Mutable pointer to the field.
    pub fn mut_smac(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.smac
    }

    // Take field
    pub fn take_smac(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.smac, ::std::vec::Vec::new())
    }

    pub fn get_smac(&self) -> &[u32] {
        &self.smac
    }

    // optional uint32 size_sigrl = 11;

    pub fn clear_size_sigrl(&mut self) {
        self.size_sigrl = ::std::option::Option::None;
    }

    pub fn has_size_sigrl(&self) -> bool {
        self.size_sigrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_sigrl(&mut self, v: u32) {
        self.size_sigrl = ::std::option::Option::Some(v);
    }

    pub fn get_size_sigrl(&self) -> u32 {
        self.size_sigrl.unwrap_or(0)
    }

    // repeated uint32 sigrl = 12;

    pub fn clear_sigrl(&mut self) {
        self.sigrl.clear();
    }

    // Param is passed by value, moved
    pub fn set_sigrl(&mut self, v: ::std::vec::Vec<u32>) {
        self.sigrl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sigrl(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.sigrl
    }

    // Take field
    pub fn take_sigrl(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.sigrl, ::std::vec::Vec::new())
    }

    pub fn get_sigrl(&self) -> &[u32] {
        &self.sigrl
    }
}

impl ::protobuf::Message for MessageMSG2 {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.public_key_gx)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.public_key_gy)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quote_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.spid)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmac_kdf_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.signature_x)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.signature_y)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.smac)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size_sigrl = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.sigrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.public_key_gx.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.public_key_gx);
        }
        if !self.public_key_gy.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.public_key_gy);
        }
        if let Some(v) = self.quote_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.spid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(6, &self.spid);
        }
        if let Some(v) = self.cmac_kdf_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.signature_x.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(8, &self.signature_x);
        }
        if !self.signature_y.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(9, &self.signature_y);
        }
        if !self.smac.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(10, &self.smac);
        }
        if let Some(v) = self.size_sigrl {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sigrl.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(12, &self.sigrl);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        if !self.public_key_gx.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.public_key_gx))?;
            for v in &self.public_key_gx {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.public_key_gy.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.public_key_gy))?;
            for v in &self.public_key_gy {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.quote_type {
            os.write_uint32(5, v)?;
        }
        if !self.spid.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.spid))?;
            for v in &self.spid {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.cmac_kdf_id {
            os.write_uint32(7, v)?;
        }
        if !self.signature_x.is_empty() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.signature_x))?;
            for v in &self.signature_x {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.signature_y.is_empty() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.signature_y))?;
            for v in &self.signature_y {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.smac.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.smac))?;
            for v in &self.smac {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.size_sigrl {
            os.write_uint32(11, v)?;
        }
        if !self.sigrl.is_empty() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.sigrl))?;
            for v in &self.sigrl {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageMSG2 {
        MessageMSG2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &MessageMSG2| { &m.field_type },
                    |m: &mut MessageMSG2| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &MessageMSG2| { &m.size },
                    |m: &mut MessageMSG2| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "public_key_gx",
                    |m: &MessageMSG2| { &m.public_key_gx },
                    |m: &mut MessageMSG2| { &mut m.public_key_gx },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "public_key_gy",
                    |m: &MessageMSG2| { &m.public_key_gy },
                    |m: &mut MessageMSG2| { &mut m.public_key_gy },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quote_type",
                    |m: &MessageMSG2| { &m.quote_type },
                    |m: &mut MessageMSG2| { &mut m.quote_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spid",
                    |m: &MessageMSG2| { &m.spid },
                    |m: &mut MessageMSG2| { &mut m.spid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmac_kdf_id",
                    |m: &MessageMSG2| { &m.cmac_kdf_id },
                    |m: &mut MessageMSG2| { &mut m.cmac_kdf_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "signature_x",
                    |m: &MessageMSG2| { &m.signature_x },
                    |m: &mut MessageMSG2| { &mut m.signature_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "signature_y",
                    |m: &MessageMSG2| { &m.signature_y },
                    |m: &mut MessageMSG2| { &mut m.signature_y },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "smac",
                    |m: &MessageMSG2| { &m.smac },
                    |m: &mut MessageMSG2| { &mut m.smac },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size_sigrl",
                    |m: &MessageMSG2| { &m.size_sigrl },
                    |m: &mut MessageMSG2| { &mut m.size_sigrl },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sigrl",
                    |m: &MessageMSG2| { &m.sigrl },
                    |m: &mut MessageMSG2| { &mut m.sigrl },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageMSG2>(
                    "MessageMSG2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageMSG2 {
        static mut instance: ::protobuf::lazy::Lazy<MessageMSG2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageMSG2,
        };
        unsafe {
            instance.get(MessageMSG2::new)
        }
    }
}

impl ::protobuf::Clear for MessageMSG2 {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_size();
        self.clear_public_key_gx();
        self.clear_public_key_gy();
        self.clear_quote_type();
        self.clear_spid();
        self.clear_cmac_kdf_id();
        self.clear_signature_x();
        self.clear_signature_y();
        self.clear_smac();
        self.clear_size_sigrl();
        self.clear_sigrl();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageMSG2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageMSG2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageMSG3 {
    // message fields
    field_type: ::std::option::Option<u32>,
    size: ::std::option::Option<u32>,
    sgx_mac: ::std::vec::Vec<u32>,
    gax_msg3: ::std::vec::Vec<u32>,
    gay_msg3: ::std::vec::Vec<u32>,
    sec_property: ::std::vec::Vec<u32>,
    quote: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MessageMSG3 {
    pub fn new() -> MessageMSG3 {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    // optional uint32 size = 2;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    // repeated uint32 sgx_mac = 3;

    pub fn clear_sgx_mac(&mut self) {
        self.sgx_mac.clear();
    }

    // Param is passed by value, moved
    pub fn set_sgx_mac(&mut self, v: ::std::vec::Vec<u32>) {
        self.sgx_mac = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sgx_mac(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.sgx_mac
    }

    // Take field
    pub fn take_sgx_mac(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.sgx_mac, ::std::vec::Vec::new())
    }

    pub fn get_sgx_mac(&self) -> &[u32] {
        &self.sgx_mac
    }

    // repeated uint32 gax_msg3 = 4;

    pub fn clear_gax_msg3(&mut self) {
        self.gax_msg3.clear();
    }

    // Param is passed by value, moved
    pub fn set_gax_msg3(&mut self, v: ::std::vec::Vec<u32>) {
        self.gax_msg3 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gax_msg3(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.gax_msg3
    }

    // Take field
    pub fn take_gax_msg3(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.gax_msg3, ::std::vec::Vec::new())
    }

    pub fn get_gax_msg3(&self) -> &[u32] {
        &self.gax_msg3
    }

    // repeated uint32 gay_msg3 = 5;

    pub fn clear_gay_msg3(&mut self) {
        self.gay_msg3.clear();
    }

    // Param is passed by value, moved
    pub fn set_gay_msg3(&mut self, v: ::std::vec::Vec<u32>) {
        self.gay_msg3 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gay_msg3(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.gay_msg3
    }

    // Take field
    pub fn take_gay_msg3(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.gay_msg3, ::std::vec::Vec::new())
    }

    pub fn get_gay_msg3(&self) -> &[u32] {
        &self.gay_msg3
    }

    // repeated uint32 sec_property = 6;

    pub fn clear_sec_property(&mut self) {
        self.sec_property.clear();
    }

    // Param is passed by value, moved
    pub fn set_sec_property(&mut self, v: ::std::vec::Vec<u32>) {
        self.sec_property = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sec_property(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.sec_property
    }

    // Take field
    pub fn take_sec_property(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.sec_property, ::std::vec::Vec::new())
    }

    pub fn get_sec_property(&self) -> &[u32] {
        &self.sec_property
    }

    // repeated uint32 quote = 7;

    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: ::std::vec::Vec<u32>) {
        self.quote = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quote(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.quote
    }

    // Take field
    pub fn take_quote(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.quote, ::std::vec::Vec::new())
    }

    pub fn get_quote(&self) -> &[u32] {
        &self.quote
    }
}

impl ::protobuf::Message for MessageMSG3 {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.sgx_mac)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.gax_msg3)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.gay_msg3)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.sec_property)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.quote)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sgx_mac.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.sgx_mac);
        }
        if !self.gax_msg3.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.gax_msg3);
        }
        if !self.gay_msg3.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(5, &self.gay_msg3);
        }
        if !self.sec_property.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(6, &self.sec_property);
        }
        if !self.quote.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(7, &self.quote);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        if !self.sgx_mac.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.sgx_mac))?;
            for v in &self.sgx_mac {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.gax_msg3.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.gax_msg3))?;
            for v in &self.gax_msg3 {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.gay_msg3.is_empty() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.gay_msg3))?;
            for v in &self.gay_msg3 {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.sec_property.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.sec_property))?;
            for v in &self.sec_property {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.quote.is_empty() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.quote))?;
            for v in &self.quote {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageMSG3 {
        MessageMSG3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &MessageMSG3| { &m.field_type },
                    |m: &mut MessageMSG3| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &MessageMSG3| { &m.size },
                    |m: &mut MessageMSG3| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sgx_mac",
                    |m: &MessageMSG3| { &m.sgx_mac },
                    |m: &mut MessageMSG3| { &mut m.sgx_mac },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gax_msg3",
                    |m: &MessageMSG3| { &m.gax_msg3 },
                    |m: &mut MessageMSG3| { &mut m.gax_msg3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gay_msg3",
                    |m: &MessageMSG3| { &m.gay_msg3 },
                    |m: &mut MessageMSG3| { &mut m.gay_msg3 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sec_property",
                    |m: &MessageMSG3| { &m.sec_property },
                    |m: &mut MessageMSG3| { &mut m.sec_property },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quote",
                    |m: &MessageMSG3| { &m.quote },
                    |m: &mut MessageMSG3| { &mut m.quote },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageMSG3>(
                    "MessageMSG3",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageMSG3 {
        static mut instance: ::protobuf::lazy::Lazy<MessageMSG3> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageMSG3,
        };
        unsafe {
            instance.get(MessageMSG3::new)
        }
    }
}

impl ::protobuf::Clear for MessageMSG3 {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_size();
        self.clear_sgx_mac();
        self.clear_gax_msg3();
        self.clear_gay_msg3();
        self.clear_sec_property();
        self.clear_quote();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageMSG3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageMSG3 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttestationMessage {
    // message fields
    field_type: ::std::option::Option<u32>,
    size: ::std::option::Option<u32>,
    epid_group_status: ::std::option::Option<u32>,
    tcb_evaluation_status: ::std::option::Option<u32>,
    pse_evaluation_status: ::std::option::Option<u32>,
    latest_equivalent_tcb_psvn: ::std::vec::Vec<u32>,
    latest_pse_isvsvn: ::std::vec::Vec<u32>,
    latest_psda_svn: ::std::vec::Vec<u32>,
    performance_rekey_gid: ::std::vec::Vec<u32>,
    ec_sign256_x: ::std::vec::Vec<u32>,
    ec_sign256_y: ::std::vec::Vec<u32>,
    mac_smk: ::std::vec::Vec<u32>,
    result_size: ::std::option::Option<u32>,
    reserved: ::std::vec::Vec<u32>,
    payload_tag: ::std::vec::Vec<u32>,
    payload: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AttestationMessage {
    pub fn new() -> AttestationMessage {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    // required uint32 size = 2;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    // optional uint32 epid_group_status = 3;

    pub fn clear_epid_group_status(&mut self) {
        self.epid_group_status = ::std::option::Option::None;
    }

    pub fn has_epid_group_status(&self) -> bool {
        self.epid_group_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epid_group_status(&mut self, v: u32) {
        self.epid_group_status = ::std::option::Option::Some(v);
    }

    pub fn get_epid_group_status(&self) -> u32 {
        self.epid_group_status.unwrap_or(0)
    }

    // optional uint32 tcb_evaluation_status = 4;

    pub fn clear_tcb_evaluation_status(&mut self) {
        self.tcb_evaluation_status = ::std::option::Option::None;
    }

    pub fn has_tcb_evaluation_status(&self) -> bool {
        self.tcb_evaluation_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcb_evaluation_status(&mut self, v: u32) {
        self.tcb_evaluation_status = ::std::option::Option::Some(v);
    }

    pub fn get_tcb_evaluation_status(&self) -> u32 {
        self.tcb_evaluation_status.unwrap_or(0)
    }

    // optional uint32 pse_evaluation_status = 5;

    pub fn clear_pse_evaluation_status(&mut self) {
        self.pse_evaluation_status = ::std::option::Option::None;
    }

    pub fn has_pse_evaluation_status(&self) -> bool {
        self.pse_evaluation_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pse_evaluation_status(&mut self, v: u32) {
        self.pse_evaluation_status = ::std::option::Option::Some(v);
    }

    pub fn get_pse_evaluation_status(&self) -> u32 {
        self.pse_evaluation_status.unwrap_or(0)
    }

    // repeated uint32 latest_equivalent_tcb_psvn = 6;

    pub fn clear_latest_equivalent_tcb_psvn(&mut self) {
        self.latest_equivalent_tcb_psvn.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_equivalent_tcb_psvn(&mut self, v: ::std::vec::Vec<u32>) {
        self.latest_equivalent_tcb_psvn = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_equivalent_tcb_psvn(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.latest_equivalent_tcb_psvn
    }

    // Take field
    pub fn take_latest_equivalent_tcb_psvn(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.latest_equivalent_tcb_psvn, ::std::vec::Vec::new())
    }

    pub fn get_latest_equivalent_tcb_psvn(&self) -> &[u32] {
        &self.latest_equivalent_tcb_psvn
    }

    // repeated uint32 latest_pse_isvsvn = 7;

    pub fn clear_latest_pse_isvsvn(&mut self) {
        self.latest_pse_isvsvn.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_pse_isvsvn(&mut self, v: ::std::vec::Vec<u32>) {
        self.latest_pse_isvsvn = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_pse_isvsvn(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.latest_pse_isvsvn
    }

    // Take field
    pub fn take_latest_pse_isvsvn(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.latest_pse_isvsvn, ::std::vec::Vec::new())
    }

    pub fn get_latest_pse_isvsvn(&self) -> &[u32] {
        &self.latest_pse_isvsvn
    }

    // repeated uint32 latest_psda_svn = 8;

    pub fn clear_latest_psda_svn(&mut self) {
        self.latest_psda_svn.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_psda_svn(&mut self, v: ::std::vec::Vec<u32>) {
        self.latest_psda_svn = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_psda_svn(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.latest_psda_svn
    }

    // Take field
    pub fn take_latest_psda_svn(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.latest_psda_svn, ::std::vec::Vec::new())
    }

    pub fn get_latest_psda_svn(&self) -> &[u32] {
        &self.latest_psda_svn
    }

    // repeated uint32 performance_rekey_gid = 9;

    pub fn clear_performance_rekey_gid(&mut self) {
        self.performance_rekey_gid.clear();
    }

    // Param is passed by value, moved
    pub fn set_performance_rekey_gid(&mut self, v: ::std::vec::Vec<u32>) {
        self.performance_rekey_gid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_performance_rekey_gid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.performance_rekey_gid
    }

    // Take field
    pub fn take_performance_rekey_gid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.performance_rekey_gid, ::std::vec::Vec::new())
    }

    pub fn get_performance_rekey_gid(&self) -> &[u32] {
        &self.performance_rekey_gid
    }

    // repeated uint32 ec_sign256_x = 10;

    pub fn clear_ec_sign256_x(&mut self) {
        self.ec_sign256_x.clear();
    }

    // Param is passed by value, moved
    pub fn set_ec_sign256_x(&mut self, v: ::std::vec::Vec<u32>) {
        self.ec_sign256_x = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ec_sign256_x(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ec_sign256_x
    }

    // Take field
    pub fn take_ec_sign256_x(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ec_sign256_x, ::std::vec::Vec::new())
    }

    pub fn get_ec_sign256_x(&self) -> &[u32] {
        &self.ec_sign256_x
    }

    // repeated uint32 ec_sign256_y = 11;

    pub fn clear_ec_sign256_y(&mut self) {
        self.ec_sign256_y.clear();
    }

    // Param is passed by value, moved
    pub fn set_ec_sign256_y(&mut self, v: ::std::vec::Vec<u32>) {
        self.ec_sign256_y = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ec_sign256_y(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ec_sign256_y
    }

    // Take field
    pub fn take_ec_sign256_y(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ec_sign256_y, ::std::vec::Vec::new())
    }

    pub fn get_ec_sign256_y(&self) -> &[u32] {
        &self.ec_sign256_y
    }

    // repeated uint32 mac_smk = 12;

    pub fn clear_mac_smk(&mut self) {
        self.mac_smk.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_smk(&mut self, v: ::std::vec::Vec<u32>) {
        self.mac_smk = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mac_smk(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mac_smk
    }

    // Take field
    pub fn take_mac_smk(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mac_smk, ::std::vec::Vec::new())
    }

    pub fn get_mac_smk(&self) -> &[u32] {
        &self.mac_smk
    }

    // optional uint32 result_size = 13;

    pub fn clear_result_size(&mut self) {
        self.result_size = ::std::option::Option::None;
    }

    pub fn has_result_size(&self) -> bool {
        self.result_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_size(&mut self, v: u32) {
        self.result_size = ::std::option::Option::Some(v);
    }

    pub fn get_result_size(&self) -> u32 {
        self.result_size.unwrap_or(0)
    }

    // repeated uint32 reserved = 14;

    pub fn clear_reserved(&mut self) {
        self.reserved.clear();
    }

    // Param is passed by value, moved
    pub fn set_reserved(&mut self, v: ::std::vec::Vec<u32>) {
        self.reserved = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reserved(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reserved
    }

    // Take field
    pub fn take_reserved(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.reserved, ::std::vec::Vec::new())
    }

    pub fn get_reserved(&self) -> &[u32] {
        &self.reserved
    }

    // repeated uint32 payload_tag = 15;

    pub fn clear_payload_tag(&mut self) {
        self.payload_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_tag(&mut self, v: ::std::vec::Vec<u32>) {
        self.payload_tag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payload_tag(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.payload_tag
    }

    // Take field
    pub fn take_payload_tag(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.payload_tag, ::std::vec::Vec::new())
    }

    pub fn get_payload_tag(&self) -> &[u32] {
        &self.payload_tag
    }

    // repeated uint32 payload = 16;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u32>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    pub fn get_payload(&self) -> &[u32] {
        &self.payload
    }
}

impl ::protobuf::Message for AttestationMessage {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.epid_group_status = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcb_evaluation_status = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pse_evaluation_status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.latest_equivalent_tcb_psvn)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.latest_pse_isvsvn)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.latest_psda_svn)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.performance_rekey_gid)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ec_sign256_x)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ec_sign256_y)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mac_smk)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result_size = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.reserved)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.payload_tag)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.epid_group_status {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tcb_evaluation_status {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pse_evaluation_status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.latest_equivalent_tcb_psvn.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(6, &self.latest_equivalent_tcb_psvn);
        }
        if !self.latest_pse_isvsvn.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(7, &self.latest_pse_isvsvn);
        }
        if !self.latest_psda_svn.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(8, &self.latest_psda_svn);
        }
        if !self.performance_rekey_gid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(9, &self.performance_rekey_gid);
        }
        if !self.ec_sign256_x.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(10, &self.ec_sign256_x);
        }
        if !self.ec_sign256_y.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(11, &self.ec_sign256_y);
        }
        if !self.mac_smk.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(12, &self.mac_smk);
        }
        if let Some(v) = self.result_size {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.reserved.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(14, &self.reserved);
        }
        if !self.payload_tag.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(15, &self.payload_tag);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(16, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.epid_group_status {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tcb_evaluation_status {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.pse_evaluation_status {
            os.write_uint32(5, v)?;
        }
        if !self.latest_equivalent_tcb_psvn.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.latest_equivalent_tcb_psvn))?;
            for v in &self.latest_equivalent_tcb_psvn {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.latest_pse_isvsvn.is_empty() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.latest_pse_isvsvn))?;
            for v in &self.latest_pse_isvsvn {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.latest_psda_svn.is_empty() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.latest_psda_svn))?;
            for v in &self.latest_psda_svn {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.performance_rekey_gid.is_empty() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.performance_rekey_gid))?;
            for v in &self.performance_rekey_gid {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.ec_sign256_x.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.ec_sign256_x))?;
            for v in &self.ec_sign256_x {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.ec_sign256_y.is_empty() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.ec_sign256_y))?;
            for v in &self.ec_sign256_y {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.mac_smk.is_empty() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.mac_smk))?;
            for v in &self.mac_smk {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.result_size {
            os.write_uint32(13, v)?;
        }
        if !self.reserved.is_empty() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.reserved))?;
            for v in &self.reserved {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.payload_tag.is_empty() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.payload_tag))?;
            for v in &self.payload_tag {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.payload.is_empty() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.payload))?;
            for v in &self.payload {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttestationMessage {
        AttestationMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &AttestationMessage| { &m.field_type },
                    |m: &mut AttestationMessage| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &AttestationMessage| { &m.size },
                    |m: &mut AttestationMessage| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "epid_group_status",
                    |m: &AttestationMessage| { &m.epid_group_status },
                    |m: &mut AttestationMessage| { &mut m.epid_group_status },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tcb_evaluation_status",
                    |m: &AttestationMessage| { &m.tcb_evaluation_status },
                    |m: &mut AttestationMessage| { &mut m.tcb_evaluation_status },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pse_evaluation_status",
                    |m: &AttestationMessage| { &m.pse_evaluation_status },
                    |m: &mut AttestationMessage| { &mut m.pse_evaluation_status },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "latest_equivalent_tcb_psvn",
                    |m: &AttestationMessage| { &m.latest_equivalent_tcb_psvn },
                    |m: &mut AttestationMessage| { &mut m.latest_equivalent_tcb_psvn },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "latest_pse_isvsvn",
                    |m: &AttestationMessage| { &m.latest_pse_isvsvn },
                    |m: &mut AttestationMessage| { &mut m.latest_pse_isvsvn },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "latest_psda_svn",
                    |m: &AttestationMessage| { &m.latest_psda_svn },
                    |m: &mut AttestationMessage| { &mut m.latest_psda_svn },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "performance_rekey_gid",
                    |m: &AttestationMessage| { &m.performance_rekey_gid },
                    |m: &mut AttestationMessage| { &mut m.performance_rekey_gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ec_sign256_x",
                    |m: &AttestationMessage| { &m.ec_sign256_x },
                    |m: &mut AttestationMessage| { &mut m.ec_sign256_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ec_sign256_y",
                    |m: &AttestationMessage| { &m.ec_sign256_y },
                    |m: &mut AttestationMessage| { &mut m.ec_sign256_y },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mac_smk",
                    |m: &AttestationMessage| { &m.mac_smk },
                    |m: &mut AttestationMessage| { &mut m.mac_smk },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result_size",
                    |m: &AttestationMessage| { &m.result_size },
                    |m: &mut AttestationMessage| { &mut m.result_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reserved",
                    |m: &AttestationMessage| { &m.reserved },
                    |m: &mut AttestationMessage| { &mut m.reserved },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "payload_tag",
                    |m: &AttestationMessage| { &m.payload_tag },
                    |m: &mut AttestationMessage| { &mut m.payload_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "payload",
                    |m: &AttestationMessage| { &m.payload },
                    |m: &mut AttestationMessage| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttestationMessage>(
                    "AttestationMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttestationMessage {
        static mut instance: ::protobuf::lazy::Lazy<AttestationMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttestationMessage,
        };
        unsafe {
            instance.get(AttestationMessage::new)
        }
    }
}

impl ::protobuf::Clear for AttestationMessage {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_size();
        self.clear_epid_group_status();
        self.clear_tcb_evaluation_status();
        self.clear_pse_evaluation_status();
        self.clear_latest_equivalent_tcb_psvn();
        self.clear_latest_pse_isvsvn();
        self.clear_latest_psda_svn();
        self.clear_performance_rekey_gid();
        self.clear_ec_sign256_x();
        self.clear_ec_sign256_y();
        self.clear_mac_smk();
        self.clear_result_size();
        self.clear_reserved();
        self.clear_payload_tag();
        self.clear_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttestationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttestationMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretMessage {
    // message fields
    field_type: ::std::option::Option<u32>,
    size: ::std::option::Option<u32>,
    encryped_pkey_size: ::std::option::Option<u32>,
    encryped_x509_size: ::std::option::Option<u32>,
    encrypted_content: ::std::vec::Vec<u32>,
    mac_smk: ::std::vec::Vec<u32>,
    encrypted_pkey: ::std::vec::Vec<u32>,
    encrypted_pkey_mac_smk: ::std::vec::Vec<u32>,
    encrypted_x509: ::std::vec::Vec<u32>,
    encrypted_x509_mac_smk: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SecretMessage {
    pub fn new() -> SecretMessage {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    // required uint32 size = 2;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    // optional uint32 encryped_pkey_size = 3;

    pub fn clear_encryped_pkey_size(&mut self) {
        self.encryped_pkey_size = ::std::option::Option::None;
    }

    pub fn has_encryped_pkey_size(&self) -> bool {
        self.encryped_pkey_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryped_pkey_size(&mut self, v: u32) {
        self.encryped_pkey_size = ::std::option::Option::Some(v);
    }

    pub fn get_encryped_pkey_size(&self) -> u32 {
        self.encryped_pkey_size.unwrap_or(0)
    }

    // optional uint32 encryped_x509_size = 4;

    pub fn clear_encryped_x509_size(&mut self) {
        self.encryped_x509_size = ::std::option::Option::None;
    }

    pub fn has_encryped_x509_size(&self) -> bool {
        self.encryped_x509_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryped_x509_size(&mut self, v: u32) {
        self.encryped_x509_size = ::std::option::Option::Some(v);
    }

    pub fn get_encryped_x509_size(&self) -> u32 {
        self.encryped_x509_size.unwrap_or(0)
    }

    // repeated uint32 encrypted_content = 5;

    pub fn clear_encrypted_content(&mut self) {
        self.encrypted_content.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_content(&mut self, v: ::std::vec::Vec<u32>) {
        self.encrypted_content = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encrypted_content(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.encrypted_content
    }

    // Take field
    pub fn take_encrypted_content(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.encrypted_content, ::std::vec::Vec::new())
    }

    pub fn get_encrypted_content(&self) -> &[u32] {
        &self.encrypted_content
    }

    // repeated uint32 mac_smk = 6;

    pub fn clear_mac_smk(&mut self) {
        self.mac_smk.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_smk(&mut self, v: ::std::vec::Vec<u32>) {
        self.mac_smk = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mac_smk(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mac_smk
    }

    // Take field
    pub fn take_mac_smk(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mac_smk, ::std::vec::Vec::new())
    }

    pub fn get_mac_smk(&self) -> &[u32] {
        &self.mac_smk
    }

    // repeated uint32 encrypted_pkey = 7;

    pub fn clear_encrypted_pkey(&mut self) {
        self.encrypted_pkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_pkey(&mut self, v: ::std::vec::Vec<u32>) {
        self.encrypted_pkey = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encrypted_pkey(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.encrypted_pkey
    }

    // Take field
    pub fn take_encrypted_pkey(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.encrypted_pkey, ::std::vec::Vec::new())
    }

    pub fn get_encrypted_pkey(&self) -> &[u32] {
        &self.encrypted_pkey
    }

    // repeated uint32 encrypted_pkey_mac_smk = 8;

    pub fn clear_encrypted_pkey_mac_smk(&mut self) {
        self.encrypted_pkey_mac_smk.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_pkey_mac_smk(&mut self, v: ::std::vec::Vec<u32>) {
        self.encrypted_pkey_mac_smk = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encrypted_pkey_mac_smk(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.encrypted_pkey_mac_smk
    }

    // Take field
    pub fn take_encrypted_pkey_mac_smk(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.encrypted_pkey_mac_smk, ::std::vec::Vec::new())
    }

    pub fn get_encrypted_pkey_mac_smk(&self) -> &[u32] {
        &self.encrypted_pkey_mac_smk
    }

    // repeated uint32 encrypted_x509 = 9;

    pub fn clear_encrypted_x509(&mut self) {
        self.encrypted_x509.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_x509(&mut self, v: ::std::vec::Vec<u32>) {
        self.encrypted_x509 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encrypted_x509(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.encrypted_x509
    }

    // Take field
    pub fn take_encrypted_x509(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.encrypted_x509, ::std::vec::Vec::new())
    }

    pub fn get_encrypted_x509(&self) -> &[u32] {
        &self.encrypted_x509
    }

    // repeated uint32 encrypted_x509_mac_smk = 10;

    pub fn clear_encrypted_x509_mac_smk(&mut self) {
        self.encrypted_x509_mac_smk.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_x509_mac_smk(&mut self, v: ::std::vec::Vec<u32>) {
        self.encrypted_x509_mac_smk = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encrypted_x509_mac_smk(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.encrypted_x509_mac_smk
    }

    // Take field
    pub fn take_encrypted_x509_mac_smk(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.encrypted_x509_mac_smk, ::std::vec::Vec::new())
    }

    pub fn get_encrypted_x509_mac_smk(&self) -> &[u32] {
        &self.encrypted_x509_mac_smk
    }
}

impl ::protobuf::Message for SecretMessage {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.encryped_pkey_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.encryped_x509_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.encrypted_content)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mac_smk)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.encrypted_pkey)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.encrypted_pkey_mac_smk)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.encrypted_x509)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.encrypted_x509_mac_smk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryped_pkey_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryped_x509_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.encrypted_content.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(5, &self.encrypted_content);
        }
        if !self.mac_smk.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(6, &self.mac_smk);
        }
        if !self.encrypted_pkey.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(7, &self.encrypted_pkey);
        }
        if !self.encrypted_pkey_mac_smk.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(8, &self.encrypted_pkey_mac_smk);
        }
        if !self.encrypted_x509.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(9, &self.encrypted_x509);
        }
        if !self.encrypted_x509_mac_smk.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(10, &self.encrypted_x509_mac_smk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.encryped_pkey_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.encryped_x509_size {
            os.write_uint32(4, v)?;
        }
        if !self.encrypted_content.is_empty() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.encrypted_content))?;
            for v in &self.encrypted_content {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.mac_smk.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.mac_smk))?;
            for v in &self.mac_smk {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.encrypted_pkey.is_empty() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.encrypted_pkey))?;
            for v in &self.encrypted_pkey {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.encrypted_pkey_mac_smk.is_empty() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.encrypted_pkey_mac_smk))?;
            for v in &self.encrypted_pkey_mac_smk {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.encrypted_x509.is_empty() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.encrypted_x509))?;
            for v in &self.encrypted_x509 {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.encrypted_x509_mac_smk.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.encrypted_x509_mac_smk))?;
            for v in &self.encrypted_x509_mac_smk {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretMessage {
        SecretMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &SecretMessage| { &m.field_type },
                    |m: &mut SecretMessage| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &SecretMessage| { &m.size },
                    |m: &mut SecretMessage| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "encryped_pkey_size",
                    |m: &SecretMessage| { &m.encryped_pkey_size },
                    |m: &mut SecretMessage| { &mut m.encryped_pkey_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "encryped_x509_size",
                    |m: &SecretMessage| { &m.encryped_x509_size },
                    |m: &mut SecretMessage| { &mut m.encryped_x509_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "encrypted_content",
                    |m: &SecretMessage| { &m.encrypted_content },
                    |m: &mut SecretMessage| { &mut m.encrypted_content },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mac_smk",
                    |m: &SecretMessage| { &m.mac_smk },
                    |m: &mut SecretMessage| { &mut m.mac_smk },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "encrypted_pkey",
                    |m: &SecretMessage| { &m.encrypted_pkey },
                    |m: &mut SecretMessage| { &mut m.encrypted_pkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "encrypted_pkey_mac_smk",
                    |m: &SecretMessage| { &m.encrypted_pkey_mac_smk },
                    |m: &mut SecretMessage| { &mut m.encrypted_pkey_mac_smk },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "encrypted_x509",
                    |m: &SecretMessage| { &m.encrypted_x509 },
                    |m: &mut SecretMessage| { &mut m.encrypted_x509 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "encrypted_x509_mac_smk",
                    |m: &SecretMessage| { &m.encrypted_x509_mac_smk },
                    |m: &mut SecretMessage| { &mut m.encrypted_x509_mac_smk },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecretMessage>(
                    "SecretMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecretMessage {
        static mut instance: ::protobuf::lazy::Lazy<SecretMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecretMessage,
        };
        unsafe {
            instance.get(SecretMessage::new)
        }
    }
}

impl ::protobuf::Clear for SecretMessage {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_size();
        self.clear_encryped_pkey_size();
        self.clear_encryped_x509_size();
        self.clear_encrypted_content();
        self.clear_mac_smk();
        self.clear_encrypted_pkey();
        self.clear_encrypted_pkey_mac_smk();
        self.clear_encrypted_x509();
        self.clear_encrypted_x509_mac_smk();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eMessages.proto\x12\x08Messages\",\n\x0eInitialMessage\x12\x0c\n\
    \x04type\x18\x01\x20\x02(\r\x12\x0c\n\x04size\x18\x02\x20\x01(\r\"9\n\
    \x0bMessageMsg0\x12\x0c\n\x04type\x18\x01\x20\x02(\r\x12\x0c\n\x04epid\
    \x18\x02\x20\x02(\r\x12\x0e\n\x06status\x18\x03\x20\x01(\r\"N\n\x0bMessa\
    geMSG1\x12\x0c\n\x04type\x18\x01\x20\x02(\r\x12\x0f\n\x03GaX\x18\x02\x20\
    \x03(\rB\x02\x10\x01\x12\x0f\n\x03GaY\x18\x03\x20\x03(\rB\x02\x10\x01\
    \x12\x0f\n\x03GID\x18\x04\x20\x03(\rB\x02\x10\x01\"\x85\x02\n\x0bMessage\
    MSG2\x12\x0c\n\x04type\x18\x01\x20\x02(\r\x12\x0c\n\x04size\x18\x02\x20\
    \x01(\r\x12\x19\n\rpublic_key_gx\x18\x03\x20\x03(\rB\x02\x10\x01\x12\x19\
    \n\rpublic_key_gy\x18\x04\x20\x03(\rB\x02\x10\x01\x12\x12\n\nquote_type\
    \x18\x05\x20\x01(\r\x12\x10\n\x04spid\x18\x06\x20\x03(\rB\x02\x10\x01\
    \x12\x13\n\x0bcmac_kdf_id\x18\x07\x20\x01(\r\x12\x17\n\x0bsignature_x\
    \x18\x08\x20\x03(\rB\x02\x10\x01\x12\x17\n\x0bsignature_y\x18\t\x20\x03(\
    \rB\x02\x10\x01\x12\x10\n\x04smac\x18\n\x20\x03(\rB\x02\x10\x01\x12\x12\
    \n\nsize_sigrl\x18\x0b\x20\x01(\r\x12\x11\n\x05sigrl\x18\x0c\x20\x03(\rB\
    \x02\x10\x01\"\x97\x01\n\x0bMessageMSG3\x12\x0c\n\x04type\x18\x01\x20\
    \x02(\r\x12\x0c\n\x04size\x18\x02\x20\x01(\r\x12\x13\n\x07sgx_mac\x18\
    \x03\x20\x03(\rB\x02\x10\x01\x12\x14\n\x08gax_msg3\x18\x04\x20\x03(\rB\
    \x02\x10\x01\x12\x14\n\x08gay_msg3\x18\x05\x20\x03(\rB\x02\x10\x01\x12\
    \x18\n\x0csec_property\x18\x06\x20\x03(\rB\x02\x10\x01\x12\x11\n\x05quot\
    e\x18\x07\x20\x03(\rB\x02\x10\x01\"\xb2\x03\n\x12AttestationMessage\x12\
    \x0c\n\x04type\x18\x01\x20\x02(\r\x12\x0c\n\x04size\x18\x02\x20\x02(\r\
    \x12\x19\n\x11epid_group_status\x18\x03\x20\x01(\r\x12\x1d\n\x15tcb_eval\
    uation_status\x18\x04\x20\x01(\r\x12\x1d\n\x15pse_evaluation_status\x18\
    \x05\x20\x01(\r\x12&\n\x1alatest_equivalent_tcb_psvn\x18\x06\x20\x03(\rB\
    \x02\x10\x01\x12\x1d\n\x11latest_pse_isvsvn\x18\x07\x20\x03(\rB\x02\x10\
    \x01\x12\x1b\n\x0flatest_psda_svn\x18\x08\x20\x03(\rB\x02\x10\x01\x12!\n\
    \x15performance_rekey_gid\x18\t\x20\x03(\rB\x02\x10\x01\x12\x18\n\x0cec_\
    sign256_x\x18\n\x20\x03(\rB\x02\x10\x01\x12\x18\n\x0cec_sign256_y\x18\
    \x0b\x20\x03(\rB\x02\x10\x01\x12\x13\n\x07mac_smk\x18\x0c\x20\x03(\rB\
    \x02\x10\x01\x12\x13\n\x0bresult_size\x18\r\x20\x01(\r\x12\x14\n\x08rese\
    rved\x18\x0e\x20\x03(\rB\x02\x10\x01\x12\x17\n\x0bpayload_tag\x18\x0f\
    \x20\x03(\rB\x02\x10\x01\x12\x13\n\x07payload\x18\x10\x20\x03(\rB\x02\
    \x10\x01\"\x97\x02\n\rSecretMessage\x12\x0c\n\x04type\x18\x01\x20\x02(\r\
    \x12\x0c\n\x04size\x18\x02\x20\x02(\r\x12\x1a\n\x12encryped_pkey_size\
    \x18\x03\x20\x01(\r\x12\x1a\n\x12encryped_x509_size\x18\x04\x20\x01(\r\
    \x12\x1d\n\x11encrypted_content\x18\x05\x20\x03(\rB\x02\x10\x01\x12\x13\
    \n\x07mac_smk\x18\x06\x20\x03(\rB\x02\x10\x01\x12\x1a\n\x0eencrypted_pke\
    y\x18\x07\x20\x03(\rB\x02\x10\x01\x12\"\n\x16encrypted_pkey_mac_smk\x18\
    \x08\x20\x03(\rB\x02\x10\x01\x12\x1a\n\x0eencrypted_x509\x18\t\x20\x03(\
    \rB\x02\x10\x01\x12\"\n\x16encrypted_x509_mac_smk\x18\n\x20\x03(\rB\x02\
    \x10\x01J\x9e8\n\x06\x12\x04\0\0P\x01\n\x08\n\x01\x02\x12\x03\x02\x08\
    \x10\n\n\n\x02\x04\0\x12\x04\x04\0\x07\x01\n\n\n\x03\x04\0\x01\x12\x03\
    \x04\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03\x05\x08!\n\x0c\n\x05\x04\0\
    \x02\0\x04\x12\x03\x05\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x05\
    \x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x05\x18\x1c\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03\x05\x1f\x20\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x06\
    \x08!\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x06\x08\x10\n\x0c\n\x05\x04\
    \0\x02\x01\x05\x12\x03\x06\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x06\x18\x1c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x06\x1f\x20\n\n\n\x02\
    \x04\x01\x12\x04\t\0\r\x01\n\n\n\x03\x04\x01\x01\x12\x03\t\x08\x13\n\x0b\
    \n\x04\x04\x01\x02\0\x12\x03\n\x08!\n\x0c\n\x05\x04\x01\x02\0\x04\x12\
    \x03\n\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\n\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03\n\x18\x1c\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\n\x1f\x20\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x0b\x08!\n\x0c\n\
    \x05\x04\x01\x02\x01\x04\x12\x03\x0b\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\
    \x05\x12\x03\x0b\x11\x17\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0b\x18\
    \x1c\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x0b\x1f\x20\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03\x0c\x08#\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\
    \x0c\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x0c\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03\x0c\x18\x1e\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03\x0c!\"\n\n\n\x02\x04\x02\x12\x04\x0f\0\x14\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03\x0f\x08\x13\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x10\
    \x08!\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03\x10\x08\x10\n\x0c\n\x05\x04\
    \x02\x02\0\x05\x12\x03\x10\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\
    \x10\x18\x1c\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x10\x1f\x20\n\x0b\n\
    \x04\x04\x02\x02\x01\x12\x03\x11\x08.\n\x0c\n\x05\x04\x02\x02\x01\x04\
    \x12\x03\x11\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x11\x11\x17\
    \n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x11\x18\x1b\n\x0c\n\x05\x04\x02\
    \x02\x01\x03\x12\x03\x11\x1e\x1f\n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x03\
    \x11\x20-\n\x0f\n\x08\x04\x02\x02\x01\x08\xe7\x07\0\x12\x03\x11!,\n\x10\
    \n\t\x04\x02\x02\x01\x08\xe7\x07\0\x02\x12\x03\x11!'\n\x11\n\n\x04\x02\
    \x02\x01\x08\xe7\x07\0\x02\0\x12\x03\x11!'\n\x12\n\x0b\x04\x02\x02\x01\
    \x08\xe7\x07\0\x02\0\x01\x12\x03\x11!'\n\x10\n\t\x04\x02\x02\x01\x08\xe7\
    \x07\0\x03\x12\x03\x11(,\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x12\x08.\n\
    \x0c\n\x05\x04\x02\x02\x02\x04\x12\x03\x12\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x02\x05\x12\x03\x12\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\
    \x12\x18\x1b\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x12\x1e\x1f\n\x0c\n\
    \x05\x04\x02\x02\x02\x08\x12\x03\x12\x20-\n\x0f\n\x08\x04\x02\x02\x02\
    \x08\xe7\x07\0\x12\x03\x12!,\n\x10\n\t\x04\x02\x02\x02\x08\xe7\x07\0\x02\
    \x12\x03\x12!'\n\x11\n\n\x04\x02\x02\x02\x08\xe7\x07\0\x02\0\x12\x03\x12\
    !'\n\x12\n\x0b\x04\x02\x02\x02\x08\xe7\x07\0\x02\0\x01\x12\x03\x12!'\n\
    \x10\n\t\x04\x02\x02\x02\x08\xe7\x07\0\x03\x12\x03\x12(,\n\x0b\n\x04\x04\
    \x02\x02\x03\x12\x03\x13\x08.\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03\
    \x13\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03\x13\x11\x17\n\x0c\n\
    \x05\x04\x02\x02\x03\x01\x12\x03\x13\x18\x1b\n\x0c\n\x05\x04\x02\x02\x03\
    \x03\x12\x03\x13\x1e\x1f\n\x0c\n\x05\x04\x02\x02\x03\x08\x12\x03\x13\x20\
    -\n\x0f\n\x08\x04\x02\x02\x03\x08\xe7\x07\0\x12\x03\x13!,\n\x10\n\t\x04\
    \x02\x02\x03\x08\xe7\x07\0\x02\x12\x03\x13!'\n\x11\n\n\x04\x02\x02\x03\
    \x08\xe7\x07\0\x02\0\x12\x03\x13!'\n\x12\n\x0b\x04\x02\x02\x03\x08\xe7\
    \x07\0\x02\0\x01\x12\x03\x13!'\n\x10\n\t\x04\x02\x02\x03\x08\xe7\x07\0\
    \x03\x12\x03\x13(,\n\n\n\x02\x04\x03\x12\x04\x16\0#\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03\x16\x08\x13\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x17\x08!\
    \n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03\x17\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03\x17\x11\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x17\
    \x18\x1c\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x17\x1f\x20\n\x0b\n\x04\
    \x04\x03\x02\x01\x12\x03\x18\x08!\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\
    \x03\x18\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03\x18\x11\x17\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\x18\x18\x1c\n\x0c\n\x05\x04\x03\
    \x02\x01\x03\x12\x03\x18\x1f\x20\n\x0b\n\x04\x04\x03\x02\x02\x12\x03\x19\
    \x088\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03\x19\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\x02\x05\x12\x03\x19\x11\x17\n\x0c\n\x05\x04\x03\x02\x02\x01\
    \x12\x03\x19\x18%\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03\x19()\n\x0c\n\
    \x05\x04\x03\x02\x02\x08\x12\x03\x19*7\n\x0f\n\x08\x04\x03\x02\x02\x08\
    \xe7\x07\0\x12\x03\x19+6\n\x10\n\t\x04\x03\x02\x02\x08\xe7\x07\0\x02\x12\
    \x03\x19+1\n\x11\n\n\x04\x03\x02\x02\x08\xe7\x07\0\x02\0\x12\x03\x19+1\n\
    \x12\n\x0b\x04\x03\x02\x02\x08\xe7\x07\0\x02\0\x01\x12\x03\x19+1\n\x10\n\
    \t\x04\x03\x02\x02\x08\xe7\x07\0\x03\x12\x03\x1926\n\x0b\n\x04\x04\x03\
    \x02\x03\x12\x03\x1a\x088\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03\x1a\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03\x1a\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\x03\x01\x12\x03\x1a\x18%\n\x0c\n\x05\x04\x03\x02\x03\x03\
    \x12\x03\x1a()\n\x0c\n\x05\x04\x03\x02\x03\x08\x12\x03\x1a*7\n\x0f\n\x08\
    \x04\x03\x02\x03\x08\xe7\x07\0\x12\x03\x1a+6\n\x10\n\t\x04\x03\x02\x03\
    \x08\xe7\x07\0\x02\x12\x03\x1a+1\n\x11\n\n\x04\x03\x02\x03\x08\xe7\x07\0\
    \x02\0\x12\x03\x1a+1\n\x12\n\x0b\x04\x03\x02\x03\x08\xe7\x07\0\x02\0\x01\
    \x12\x03\x1a+1\n\x10\n\t\x04\x03\x02\x03\x08\xe7\x07\0\x03\x12\x03\x1a26\
    \n\x0b\n\x04\x04\x03\x02\x04\x12\x03\x1b\x08'\n\x0c\n\x05\x04\x03\x02\
    \x04\x04\x12\x03\x1b\x08\x10\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03\x1b\
    \x11\x17\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03\x1b\x18\"\n\x0c\n\x05\
    \x04\x03\x02\x04\x03\x12\x03\x1b%&\n\x0b\n\x04\x04\x03\x02\x05\x12\x03\
    \x1c\x08/\n\x0c\n\x05\x04\x03\x02\x05\x04\x12\x03\x1c\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\x05\x05\x12\x03\x1c\x11\x17\n\x0c\n\x05\x04\x03\x02\x05\
    \x01\x12\x03\x1c\x18\x1c\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03\x1c\x1f\
    \x20\n\x0c\n\x05\x04\x03\x02\x05\x08\x12\x03\x1c!.\n\x0f\n\x08\x04\x03\
    \x02\x05\x08\xe7\x07\0\x12\x03\x1c\"-\n\x10\n\t\x04\x03\x02\x05\x08\xe7\
    \x07\0\x02\x12\x03\x1c\"(\n\x11\n\n\x04\x03\x02\x05\x08\xe7\x07\0\x02\0\
    \x12\x03\x1c\"(\n\x12\n\x0b\x04\x03\x02\x05\x08\xe7\x07\0\x02\0\x01\x12\
    \x03\x1c\"(\n\x10\n\t\x04\x03\x02\x05\x08\xe7\x07\0\x03\x12\x03\x1c)-\n\
    \x0b\n\x04\x04\x03\x02\x06\x12\x03\x1d\x08(\n\x0c\n\x05\x04\x03\x02\x06\
    \x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x03\x1d\x11\
    \x17\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03\x1d\x18#\n\x0c\n\x05\x04\
    \x03\x02\x06\x03\x12\x03\x1d&'\n\x0b\n\x04\x04\x03\x02\x07\x12\x03\x1e\
    \x086\n\x0c\n\x05\x04\x03\x02\x07\x04\x12\x03\x1e\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\x07\x05\x12\x03\x1e\x11\x17\n\x0c\n\x05\x04\x03\x02\x07\x01\
    \x12\x03\x1e\x18#\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\x03\x1e&'\n\x0c\n\
    \x05\x04\x03\x02\x07\x08\x12\x03\x1e(5\n\x0f\n\x08\x04\x03\x02\x07\x08\
    \xe7\x07\0\x12\x03\x1e)4\n\x10\n\t\x04\x03\x02\x07\x08\xe7\x07\0\x02\x12\
    \x03\x1e)/\n\x11\n\n\x04\x03\x02\x07\x08\xe7\x07\0\x02\0\x12\x03\x1e)/\n\
    \x12\n\x0b\x04\x03\x02\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x1e)/\n\x10\n\
    \t\x04\x03\x02\x07\x08\xe7\x07\0\x03\x12\x03\x1e04\n\x0b\n\x04\x04\x03\
    \x02\x08\x12\x03\x1f\x086\n\x0c\n\x05\x04\x03\x02\x08\x04\x12\x03\x1f\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x08\x05\x12\x03\x1f\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\x08\x01\x12\x03\x1f\x18#\n\x0c\n\x05\x04\x03\x02\x08\x03\
    \x12\x03\x1f&'\n\x0c\n\x05\x04\x03\x02\x08\x08\x12\x03\x1f(5\n\x0f\n\x08\
    \x04\x03\x02\x08\x08\xe7\x07\0\x12\x03\x1f)4\n\x10\n\t\x04\x03\x02\x08\
    \x08\xe7\x07\0\x02\x12\x03\x1f)/\n\x11\n\n\x04\x03\x02\x08\x08\xe7\x07\0\
    \x02\0\x12\x03\x1f)/\n\x12\n\x0b\x04\x03\x02\x08\x08\xe7\x07\0\x02\0\x01\
    \x12\x03\x1f)/\n\x10\n\t\x04\x03\x02\x08\x08\xe7\x07\0\x03\x12\x03\x1f04\
    \n\x0b\n\x04\x04\x03\x02\t\x12\x03\x20\x080\n\x0c\n\x05\x04\x03\x02\t\
    \x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\x03\x02\t\x05\x12\x03\x20\x11\
    \x17\n\x0c\n\x05\x04\x03\x02\t\x01\x12\x03\x20\x18\x1c\n\x0c\n\x05\x04\
    \x03\x02\t\x03\x12\x03\x20\x1f!\n\x0c\n\x05\x04\x03\x02\t\x08\x12\x03\
    \x20\"/\n\x0f\n\x08\x04\x03\x02\t\x08\xe7\x07\0\x12\x03\x20#.\n\x10\n\t\
    \x04\x03\x02\t\x08\xe7\x07\0\x02\x12\x03\x20#)\n\x11\n\n\x04\x03\x02\t\
    \x08\xe7\x07\0\x02\0\x12\x03\x20#)\n\x12\n\x0b\x04\x03\x02\t\x08\xe7\x07\
    \0\x02\0\x01\x12\x03\x20#)\n\x10\n\t\x04\x03\x02\t\x08\xe7\x07\0\x03\x12\
    \x03\x20*.\n\x0b\n\x04\x04\x03\x02\n\x12\x03!\x08(\n\x0c\n\x05\x04\x03\
    \x02\n\x04\x12\x03!\x08\x10\n\x0c\n\x05\x04\x03\x02\n\x05\x12\x03!\x11\
    \x17\n\x0c\n\x05\x04\x03\x02\n\x01\x12\x03!\x18\"\n\x0c\n\x05\x04\x03\
    \x02\n\x03\x12\x03!%'\n\x0b\n\x04\x04\x03\x02\x0b\x12\x03\"\x081\n\x0c\n\
    \x05\x04\x03\x02\x0b\x04\x12\x03\"\x08\x10\n\x0c\n\x05\x04\x03\x02\x0b\
    \x05\x12\x03\"\x11\x17\n\x0c\n\x05\x04\x03\x02\x0b\x01\x12\x03\"\x18\x1d\
    \n\x0c\n\x05\x04\x03\x02\x0b\x03\x12\x03\"\x20\"\n\x0c\n\x05\x04\x03\x02\
    \x0b\x08\x12\x03\"#0\n\x0f\n\x08\x04\x03\x02\x0b\x08\xe7\x07\0\x12\x03\"\
    $/\n\x10\n\t\x04\x03\x02\x0b\x08\xe7\x07\0\x02\x12\x03\"$*\n\x11\n\n\x04\
    \x03\x02\x0b\x08\xe7\x07\0\x02\0\x12\x03\"$*\n\x12\n\x0b\x04\x03\x02\x0b\
    \x08\xe7\x07\0\x02\0\x01\x12\x03\"$*\n\x10\n\t\x04\x03\x02\x0b\x08\xe7\
    \x07\0\x03\x12\x03\"+/\n\n\n\x02\x04\x04\x12\x04%\0-\x01\n\n\n\x03\x04\
    \x04\x01\x12\x03%\x08\x13\n\x0b\n\x04\x04\x04\x02\0\x12\x03&\x08!\n\x0c\
    \n\x05\x04\x04\x02\0\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03&\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03&\x18\x1c\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03&\x1f\x20\n\x0b\n\x04\x04\x04\x02\x01\x12\
    \x03'\x08!\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03'\x08\x10\n\x0c\n\x05\
    \x04\x04\x02\x01\x05\x12\x03'\x11\x17\n\x0c\n\x05\x04\x04\x02\x01\x01\
    \x12\x03'\x18\x1c\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03'\x1f\x20\n\x0b\
    \n\x04\x04\x04\x02\x02\x12\x03(\x082\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\
    \x03(\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03(\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x02\x01\x12\x03(\x18\x1f\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x03(\"#\n\x0c\n\x05\x04\x04\x02\x02\x08\x12\x03($1\n\x0f\n\x08\
    \x04\x04\x02\x02\x08\xe7\x07\0\x12\x03(%0\n\x10\n\t\x04\x04\x02\x02\x08\
    \xe7\x07\0\x02\x12\x03(%+\n\x11\n\n\x04\x04\x02\x02\x08\xe7\x07\0\x02\0\
    \x12\x03(%+\n\x12\n\x0b\x04\x04\x02\x02\x08\xe7\x07\0\x02\0\x01\x12\x03(\
    %+\n\x10\n\t\x04\x04\x02\x02\x08\xe7\x07\0\x03\x12\x03(,0\n\x0b\n\x04\
    \x04\x04\x02\x03\x12\x03)\x083\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03)\
    \x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03)\x11\x17\n\x0c\n\x05\
    \x04\x04\x02\x03\x01\x12\x03)\x18\x20\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x03)#$\n\x0c\n\x05\x04\x04\x02\x03\x08\x12\x03)%2\n\x0f\n\x08\x04\
    \x04\x02\x03\x08\xe7\x07\0\x12\x03)&1\n\x10\n\t\x04\x04\x02\x03\x08\xe7\
    \x07\0\x02\x12\x03)&,\n\x11\n\n\x04\x04\x02\x03\x08\xe7\x07\0\x02\0\x12\
    \x03)&,\n\x12\n\x0b\x04\x04\x02\x03\x08\xe7\x07\0\x02\0\x01\x12\x03)&,\n\
    \x10\n\t\x04\x04\x02\x03\x08\xe7\x07\0\x03\x12\x03)-1\n\x0b\n\x04\x04\
    \x04\x02\x04\x12\x03*\x083\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03*\x08\
    \x10\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\x03*\x11\x17\n\x0c\n\x05\x04\
    \x04\x02\x04\x01\x12\x03*\x18\x20\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\
    \x03*#$\n\x0c\n\x05\x04\x04\x02\x04\x08\x12\x03*%2\n\x0f\n\x08\x04\x04\
    \x02\x04\x08\xe7\x07\0\x12\x03*&1\n\x10\n\t\x04\x04\x02\x04\x08\xe7\x07\
    \0\x02\x12\x03*&,\n\x11\n\n\x04\x04\x02\x04\x08\xe7\x07\0\x02\0\x12\x03*\
    &,\n\x12\n\x0b\x04\x04\x02\x04\x08\xe7\x07\0\x02\0\x01\x12\x03*&,\n\x10\
    \n\t\x04\x04\x02\x04\x08\xe7\x07\0\x03\x12\x03*-1\n\x0b\n\x04\x04\x04\
    \x02\x05\x12\x03+\x087\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03+\x08\x10\
    \n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03+\x11\x17\n\x0c\n\x05\x04\x04\
    \x02\x05\x01\x12\x03+\x18$\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03+'(\n\
    \x0c\n\x05\x04\x04\x02\x05\x08\x12\x03+)6\n\x0f\n\x08\x04\x04\x02\x05\
    \x08\xe7\x07\0\x12\x03+*5\n\x10\n\t\x04\x04\x02\x05\x08\xe7\x07\0\x02\
    \x12\x03+*0\n\x11\n\n\x04\x04\x02\x05\x08\xe7\x07\0\x02\0\x12\x03+*0\n\
    \x12\n\x0b\x04\x04\x02\x05\x08\xe7\x07\0\x02\0\x01\x12\x03+*0\n\x10\n\t\
    \x04\x04\x02\x05\x08\xe7\x07\0\x03\x12\x03+15\n\x0b\n\x04\x04\x04\x02\
    \x06\x12\x03,\x080\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03,\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x06\x05\x12\x03,\x11\x17\n\x0c\n\x05\x04\x04\x02\
    \x06\x01\x12\x03,\x18\x1d\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03,\x20!\
    \n\x0c\n\x05\x04\x04\x02\x06\x08\x12\x03,\"/\n\x0f\n\x08\x04\x04\x02\x06\
    \x08\xe7\x07\0\x12\x03,#.\n\x10\n\t\x04\x04\x02\x06\x08\xe7\x07\0\x02\
    \x12\x03,#)\n\x11\n\n\x04\x04\x02\x06\x08\xe7\x07\0\x02\0\x12\x03,#)\n\
    \x12\n\x0b\x04\x04\x02\x06\x08\xe7\x07\0\x02\0\x01\x12\x03,#)\n\x10\n\t\
    \x04\x04\x02\x06\x08\xe7\x07\0\x03\x12\x03,*.\n\n\n\x02\x04\x05\x12\x04/\
    \0B\x01\n\n\n\x03\x04\x05\x01\x12\x03/\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x030\x08!\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x030\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x030\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x030\x18\x1c\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x030\x1f\x20\n\x0b\n\
    \x04\x04\x05\x02\x01\x12\x031\x08!\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\
    \x031\x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x031\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\x01\x01\x12\x031\x18\x1c\n\x0c\n\x05\x04\x05\x02\x01\
    \x03\x12\x031\x1f\x20\n\x0b\n\x04\x04\x05\x02\x02\x12\x033\x08.\n\x0c\n\
    \x05\x04\x05\x02\x02\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x033\x11\x17\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x033\x18)\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x033,-\n\x0b\n\x04\x04\x05\x02\x03\
    \x12\x034\x082\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x034\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\x03\x05\x12\x034\x11\x17\n\x0c\n\x05\x04\x05\x02\x03\
    \x01\x12\x034\x18-\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03401\n\x0b\n\
    \x04\x04\x05\x02\x04\x12\x035\x082\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\
    \x035\x08\x10\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x035\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\x04\x01\x12\x035\x18-\n\x0c\n\x05\x04\x05\x02\x04\x03\
    \x12\x03501\n\x0b\n\x04\x04\x05\x02\x05\x12\x036\x08E\n\x0c\n\x05\x04\
    \x05\x02\x05\x04\x12\x036\x08\x10\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\
    \x036\x11\x17\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x036\x182\n\x0c\n\x05\
    \x04\x05\x02\x05\x03\x12\x03656\n\x0c\n\x05\x04\x05\x02\x05\x08\x12\x036\
    7D\n\x0f\n\x08\x04\x05\x02\x05\x08\xe7\x07\0\x12\x0368C\n\x10\n\t\x04\
    \x05\x02\x05\x08\xe7\x07\0\x02\x12\x0368>\n\x11\n\n\x04\x05\x02\x05\x08\
    \xe7\x07\0\x02\0\x12\x0368>\n\x12\n\x0b\x04\x05\x02\x05\x08\xe7\x07\0\
    \x02\0\x01\x12\x0368>\n\x10\n\t\x04\x05\x02\x05\x08\xe7\x07\0\x03\x12\
    \x036?C\n\x0b\n\x04\x04\x05\x02\x06\x12\x037\x08<\n\x0c\n\x05\x04\x05\
    \x02\x06\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\x037\
    \x11\x17\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x037\x18)\n\x0c\n\x05\x04\
    \x05\x02\x06\x03\x12\x037,-\n\x0c\n\x05\x04\x05\x02\x06\x08\x12\x037.;\n\
    \x0f\n\x08\x04\x05\x02\x06\x08\xe7\x07\0\x12\x037/:\n\x10\n\t\x04\x05\
    \x02\x06\x08\xe7\x07\0\x02\x12\x037/5\n\x11\n\n\x04\x05\x02\x06\x08\xe7\
    \x07\0\x02\0\x12\x037/5\n\x12\n\x0b\x04\x05\x02\x06\x08\xe7\x07\0\x02\0\
    \x01\x12\x037/5\n\x10\n\t\x04\x05\x02\x06\x08\xe7\x07\0\x03\x12\x0376:\n\
    \x0b\n\x04\x04\x05\x02\x07\x12\x038\x08:\n\x0c\n\x05\x04\x05\x02\x07\x04\
    \x12\x038\x08\x10\n\x0c\n\x05\x04\x05\x02\x07\x05\x12\x038\x11\x17\n\x0c\
    \n\x05\x04\x05\x02\x07\x01\x12\x038\x18'\n\x0c\n\x05\x04\x05\x02\x07\x03\
    \x12\x038*+\n\x0c\n\x05\x04\x05\x02\x07\x08\x12\x038,9\n\x0f\n\x08\x04\
    \x05\x02\x07\x08\xe7\x07\0\x12\x038-8\n\x10\n\t\x04\x05\x02\x07\x08\xe7\
    \x07\0\x02\x12\x038-3\n\x11\n\n\x04\x05\x02\x07\x08\xe7\x07\0\x02\0\x12\
    \x038-3\n\x12\n\x0b\x04\x05\x02\x07\x08\xe7\x07\0\x02\0\x01\x12\x038-3\n\
    \x10\n\t\x04\x05\x02\x07\x08\xe7\x07\0\x03\x12\x03848\n\x0b\n\x04\x04\
    \x05\x02\x08\x12\x039\x08@\n\x0c\n\x05\x04\x05\x02\x08\x04\x12\x039\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\x08\x05\x12\x039\x11\x17\n\x0c\n\x05\x04\
    \x05\x02\x08\x01\x12\x039\x18-\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\x0390\
    1\n\x0c\n\x05\x04\x05\x02\x08\x08\x12\x0392?\n\x0f\n\x08\x04\x05\x02\x08\
    \x08\xe7\x07\0\x12\x0393>\n\x10\n\t\x04\x05\x02\x08\x08\xe7\x07\0\x02\
    \x12\x03939\n\x11\n\n\x04\x05\x02\x08\x08\xe7\x07\0\x02\0\x12\x03939\n\
    \x12\n\x0b\x04\x05\x02\x08\x08\xe7\x07\0\x02\0\x01\x12\x03939\n\x10\n\t\
    \x04\x05\x02\x08\x08\xe7\x07\0\x03\x12\x039:>\n\x0b\n\x04\x04\x05\x02\t\
    \x12\x03:\x088\n\x0c\n\x05\x04\x05\x02\t\x04\x12\x03:\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\t\x05\x12\x03:\x11\x17\n\x0c\n\x05\x04\x05\x02\t\x01\
    \x12\x03:\x18$\n\x0c\n\x05\x04\x05\x02\t\x03\x12\x03:')\n\x0c\n\x05\x04\
    \x05\x02\t\x08\x12\x03:*7\n\x0f\n\x08\x04\x05\x02\t\x08\xe7\x07\0\x12\
    \x03:+6\n\x10\n\t\x04\x05\x02\t\x08\xe7\x07\0\x02\x12\x03:+1\n\x11\n\n\
    \x04\x05\x02\t\x08\xe7\x07\0\x02\0\x12\x03:+1\n\x12\n\x0b\x04\x05\x02\t\
    \x08\xe7\x07\0\x02\0\x01\x12\x03:+1\n\x10\n\t\x04\x05\x02\t\x08\xe7\x07\
    \0\x03\x12\x03:26\n\x0b\n\x04\x04\x05\x02\n\x12\x03;\x088\n\x0c\n\x05\
    \x04\x05\x02\n\x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\x05\x02\n\x05\x12\
    \x03;\x11\x17\n\x0c\n\x05\x04\x05\x02\n\x01\x12\x03;\x18$\n\x0c\n\x05\
    \x04\x05\x02\n\x03\x12\x03;')\n\x0c\n\x05\x04\x05\x02\n\x08\x12\x03;*7\n\
    \x0f\n\x08\x04\x05\x02\n\x08\xe7\x07\0\x12\x03;+6\n\x10\n\t\x04\x05\x02\
    \n\x08\xe7\x07\0\x02\x12\x03;+1\n\x11\n\n\x04\x05\x02\n\x08\xe7\x07\0\
    \x02\0\x12\x03;+1\n\x12\n\x0b\x04\x05\x02\n\x08\xe7\x07\0\x02\0\x01\x12\
    \x03;+1\n\x10\n\t\x04\x05\x02\n\x08\xe7\x07\0\x03\x12\x03;26\n\x0b\n\x04\
    \x04\x05\x02\x0b\x12\x03<\x083\n\x0c\n\x05\x04\x05\x02\x0b\x04\x12\x03<\
    \x08\x10\n\x0c\n\x05\x04\x05\x02\x0b\x05\x12\x03<\x11\x17\n\x0c\n\x05\
    \x04\x05\x02\x0b\x01\x12\x03<\x18\x1f\n\x0c\n\x05\x04\x05\x02\x0b\x03\
    \x12\x03<\"$\n\x0c\n\x05\x04\x05\x02\x0b\x08\x12\x03<%2\n\x0f\n\x08\x04\
    \x05\x02\x0b\x08\xe7\x07\0\x12\x03<&1\n\x10\n\t\x04\x05\x02\x0b\x08\xe7\
    \x07\0\x02\x12\x03<&,\n\x11\n\n\x04\x05\x02\x0b\x08\xe7\x07\0\x02\0\x12\
    \x03<&,\n\x12\n\x0b\x04\x05\x02\x0b\x08\xe7\x07\0\x02\0\x01\x12\x03<&,\n\
    \x10\n\t\x04\x05\x02\x0b\x08\xe7\x07\0\x03\x12\x03<-1\n\x0b\n\x04\x04\
    \x05\x02\x0c\x12\x03>\x08)\n\x0c\n\x05\x04\x05\x02\x0c\x04\x12\x03>\x08\
    \x10\n\x0c\n\x05\x04\x05\x02\x0c\x05\x12\x03>\x11\x17\n\x0c\n\x05\x04\
    \x05\x02\x0c\x01\x12\x03>\x18#\n\x0c\n\x05\x04\x05\x02\x0c\x03\x12\x03>&\
    (\n\x0b\n\x04\x04\x05\x02\r\x12\x03?\x084\n\x0c\n\x05\x04\x05\x02\r\x04\
    \x12\x03?\x08\x10\n\x0c\n\x05\x04\x05\x02\r\x05\x12\x03?\x11\x17\n\x0c\n\
    \x05\x04\x05\x02\r\x01\x12\x03?\x18\x20\n\x0c\n\x05\x04\x05\x02\r\x03\
    \x12\x03?#%\n\x0c\n\x05\x04\x05\x02\r\x08\x12\x03?&3\n\x0f\n\x08\x04\x05\
    \x02\r\x08\xe7\x07\0\x12\x03?'2\n\x10\n\t\x04\x05\x02\r\x08\xe7\x07\0\
    \x02\x12\x03?'-\n\x11\n\n\x04\x05\x02\r\x08\xe7\x07\0\x02\0\x12\x03?'-\n\
    \x12\n\x0b\x04\x05\x02\r\x08\xe7\x07\0\x02\0\x01\x12\x03?'-\n\x10\n\t\
    \x04\x05\x02\r\x08\xe7\x07\0\x03\x12\x03?.2\n\x0b\n\x04\x04\x05\x02\x0e\
    \x12\x03@\x087\n\x0c\n\x05\x04\x05\x02\x0e\x04\x12\x03@\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\x0e\x05\x12\x03@\x11\x17\n\x0c\n\x05\x04\x05\x02\x0e\
    \x01\x12\x03@\x18#\n\x0c\n\x05\x04\x05\x02\x0e\x03\x12\x03@&(\n\x0c\n\
    \x05\x04\x05\x02\x0e\x08\x12\x03@)6\n\x0f\n\x08\x04\x05\x02\x0e\x08\xe7\
    \x07\0\x12\x03@*5\n\x10\n\t\x04\x05\x02\x0e\x08\xe7\x07\0\x02\x12\x03@*0\
    \n\x11\n\n\x04\x05\x02\x0e\x08\xe7\x07\0\x02\0\x12\x03@*0\n\x12\n\x0b\
    \x04\x05\x02\x0e\x08\xe7\x07\0\x02\0\x01\x12\x03@*0\n\x10\n\t\x04\x05\
    \x02\x0e\x08\xe7\x07\0\x03\x12\x03@15\n\x0b\n\x04\x04\x05\x02\x0f\x12\
    \x03A\x083\n\x0c\n\x05\x04\x05\x02\x0f\x04\x12\x03A\x08\x10\n\x0c\n\x05\
    \x04\x05\x02\x0f\x05\x12\x03A\x11\x17\n\x0c\n\x05\x04\x05\x02\x0f\x01\
    \x12\x03A\x18\x1f\n\x0c\n\x05\x04\x05\x02\x0f\x03\x12\x03A\"$\n\x0c\n\
    \x05\x04\x05\x02\x0f\x08\x12\x03A%2\n\x0f\n\x08\x04\x05\x02\x0f\x08\xe7\
    \x07\0\x12\x03A&1\n\x10\n\t\x04\x05\x02\x0f\x08\xe7\x07\0\x02\x12\x03A&,\
    \n\x11\n\n\x04\x05\x02\x0f\x08\xe7\x07\0\x02\0\x12\x03A&,\n\x12\n\x0b\
    \x04\x05\x02\x0f\x08\xe7\x07\0\x02\0\x01\x12\x03A&,\n\x10\n\t\x04\x05\
    \x02\x0f\x08\xe7\x07\0\x03\x12\x03A-1\n\n\n\x02\x04\x06\x12\x04D\0P\x01\
    \n\n\n\x03\x04\x06\x01\x12\x03D\x08\x15\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03E\x02\x1b\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03E\x02\n\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03E\x0b\x11\n\x0c\n\x05\x04\x06\x02\0\x01\x12\
    \x03E\x12\x16\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03E\x19\x1a\n\x0b\n\x04\
    \x04\x06\x02\x01\x12\x03F\x02\x1b\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\
    \x03F\x02\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03F\x0b\x11\n\x0c\n\x05\
    \x04\x06\x02\x01\x01\x12\x03F\x12\x16\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03F\x19\x1a\n\x0b\n\x04\x04\x06\x02\x02\x12\x03H\x02)\n\x0c\n\x05\
    \x04\x06\x02\x02\x04\x12\x03H\x02\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\
    \x03H\x0b\x11\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03H\x12$\n\x0c\n\x05\
    \x04\x06\x02\x02\x03\x12\x03H'(\n\x0b\n\x04\x04\x06\x02\x03\x12\x03I\x02\
    )\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03I\x02\n\n\x0c\n\x05\x04\x06\x02\
    \x03\x05\x12\x03I\x0b\x11\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03I\x12$\
    \n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03I'(\n\x0b\n\x04\x04\x06\x02\x04\
    \x12\x03J\x028\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03J\x02\n\n\x0c\n\
    \x05\x04\x06\x02\x04\x05\x12\x03J\x0b\x11\n\x0c\n\x05\x04\x06\x02\x04\
    \x01\x12\x03J\x12#\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03J&'\n\x0c\n\
    \x05\x04\x06\x02\x04\x08\x12\x03J(7\n\x0f\n\x08\x04\x06\x02\x04\x08\xe7\
    \x07\0\x12\x03J)6\n\x10\n\t\x04\x06\x02\x04\x08\xe7\x07\0\x02\x12\x03J)/\
    \n\x11\n\n\x04\x06\x02\x04\x08\xe7\x07\0\x02\0\x12\x03J)/\n\x12\n\x0b\
    \x04\x06\x02\x04\x08\xe7\x07\0\x02\0\x01\x12\x03J)/\n\x10\n\t\x04\x06\
    \x02\x04\x08\xe7\x07\0\x03\x12\x03J26\n\x0b\n\x04\x04\x06\x02\x05\x12\
    \x03K\x02.\n\x0c\n\x05\x04\x06\x02\x05\x04\x12\x03K\x02\n\n\x0c\n\x05\
    \x04\x06\x02\x05\x05\x12\x03K\x0b\x11\n\x0c\n\x05\x04\x06\x02\x05\x01\
    \x12\x03K\x12\x19\n\x0c\n\x05\x04\x06\x02\x05\x03\x12\x03K\x1c\x1d\n\x0c\
    \n\x05\x04\x06\x02\x05\x08\x12\x03K\x1e-\n\x0f\n\x08\x04\x06\x02\x05\x08\
    \xe7\x07\0\x12\x03K\x1f,\n\x10\n\t\x04\x06\x02\x05\x08\xe7\x07\0\x02\x12\
    \x03K\x1f%\n\x11\n\n\x04\x06\x02\x05\x08\xe7\x07\0\x02\0\x12\x03K\x1f%\n\
    \x12\n\x0b\x04\x06\x02\x05\x08\xe7\x07\0\x02\0\x01\x12\x03K\x1f%\n\x10\n\
    \t\x04\x06\x02\x05\x08\xe7\x07\0\x03\x12\x03K(,\n\x0b\n\x04\x04\x06\x02\
    \x06\x12\x03L\x025\n\x0c\n\x05\x04\x06\x02\x06\x04\x12\x03L\x02\n\n\x0c\
    \n\x05\x04\x06\x02\x06\x05\x12\x03L\x0b\x11\n\x0c\n\x05\x04\x06\x02\x06\
    \x01\x12\x03L\x12\x20\n\x0c\n\x05\x04\x06\x02\x06\x03\x12\x03L#$\n\x0c\n\
    \x05\x04\x06\x02\x06\x08\x12\x03L%4\n\x0f\n\x08\x04\x06\x02\x06\x08\xe7\
    \x07\0\x12\x03L&3\n\x10\n\t\x04\x06\x02\x06\x08\xe7\x07\0\x02\x12\x03L&,\
    \n\x11\n\n\x04\x06\x02\x06\x08\xe7\x07\0\x02\0\x12\x03L&,\n\x12\n\x0b\
    \x04\x06\x02\x06\x08\xe7\x07\0\x02\0\x01\x12\x03L&,\n\x10\n\t\x04\x06\
    \x02\x06\x08\xe7\x07\0\x03\x12\x03L/3\n\x0b\n\x04\x04\x06\x02\x07\x12\
    \x03M\x02=\n\x0c\n\x05\x04\x06\x02\x07\x04\x12\x03M\x02\n\n\x0c\n\x05\
    \x04\x06\x02\x07\x05\x12\x03M\x0b\x11\n\x0c\n\x05\x04\x06\x02\x07\x01\
    \x12\x03M\x12(\n\x0c\n\x05\x04\x06\x02\x07\x03\x12\x03M+,\n\x0c\n\x05\
    \x04\x06\x02\x07\x08\x12\x03M-<\n\x0f\n\x08\x04\x06\x02\x07\x08\xe7\x07\
    \0\x12\x03M.;\n\x10\n\t\x04\x06\x02\x07\x08\xe7\x07\0\x02\x12\x03M.4\n\
    \x11\n\n\x04\x06\x02\x07\x08\xe7\x07\0\x02\0\x12\x03M.4\n\x12\n\x0b\x04\
    \x06\x02\x07\x08\xe7\x07\0\x02\0\x01\x12\x03M.4\n\x10\n\t\x04\x06\x02\
    \x07\x08\xe7\x07\0\x03\x12\x03M7;\n\x0b\n\x04\x04\x06\x02\x08\x12\x03N\
    \x025\n\x0c\n\x05\x04\x06\x02\x08\x04\x12\x03N\x02\n\n\x0c\n\x05\x04\x06\
    \x02\x08\x05\x12\x03N\x0b\x11\n\x0c\n\x05\x04\x06\x02\x08\x01\x12\x03N\
    \x12\x20\n\x0c\n\x05\x04\x06\x02\x08\x03\x12\x03N#$\n\x0c\n\x05\x04\x06\
    \x02\x08\x08\x12\x03N%4\n\x0f\n\x08\x04\x06\x02\x08\x08\xe7\x07\0\x12\
    \x03N&3\n\x10\n\t\x04\x06\x02\x08\x08\xe7\x07\0\x02\x12\x03N&,\n\x11\n\n\
    \x04\x06\x02\x08\x08\xe7\x07\0\x02\0\x12\x03N&,\n\x12\n\x0b\x04\x06\x02\
    \x08\x08\xe7\x07\0\x02\0\x01\x12\x03N&,\n\x10\n\t\x04\x06\x02\x08\x08\
    \xe7\x07\0\x03\x12\x03N/3\n\x0b\n\x04\x04\x06\x02\t\x12\x03O\x02>\n\x0c\
    \n\x05\x04\x06\x02\t\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\x06\x02\t\x05\
    \x12\x03O\x0b\x11\n\x0c\n\x05\x04\x06\x02\t\x01\x12\x03O\x12(\n\x0c\n\
    \x05\x04\x06\x02\t\x03\x12\x03O+-\n\x0c\n\x05\x04\x06\x02\t\x08\x12\x03O\
    .=\n\x0f\n\x08\x04\x06\x02\t\x08\xe7\x07\0\x12\x03O/<\n\x10\n\t\x04\x06\
    \x02\t\x08\xe7\x07\0\x02\x12\x03O/5\n\x11\n\n\x04\x06\x02\t\x08\xe7\x07\
    \0\x02\0\x12\x03O/5\n\x12\n\x0b\x04\x06\x02\t\x08\xe7\x07\0\x02\0\x01\
    \x12\x03O/5\n\x10\n\t\x04\x06\x02\t\x08\xe7\x07\0\x03\x12\x03O8<\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
